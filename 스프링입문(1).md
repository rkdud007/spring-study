## 프로젝트 환경설정 

### 프로젝트 생성

1. 세팅
    - Java 11
    - IntelliJ
    - [https://start.spring.io/](https://start.spring.io/)
2. 구조 설명 
    - src
        - main
            - java : 실제 자바 코드파일
            - resources : 자바를 제외한 xml, 설정파일, html emd
        - test : 요즘 테스트 파일은 기본으로 들어가 있다.
    - build.gradle : 스프링 부트가 나오면서 이런 설정파일 제공
    - gitignore : git에는 중요한 정보들이 올라가면 안됨
3. 실행
    - java 파일 내부의 클래스 @SpringBootApplication 어노테이션 붙은거 메인을 실행 → 8080 포트에 에러페이지 뜸
    - SpringApplication.run하면, 자체적으로 톰캣이라는 서버를 같이 띄운다.

### 라이브러리 살펴보기

- 스프링 부트 라이브러리에 들어가보면 3개 밖에 없지만
- 실제 라이브러리 ( External Libaries ) 는 훨씬 많다
    - meaven같은 툴들은 의존관계를 전부 관리해준다 : 우리가 필요한 라이브러리 A가 존재할때, A가 의존하고있는 모든 라이브러리 들을 자동으로 땡겨온다.

### View 환경설정

- 이전에는 View 설정을 안해두어서 에러 페이지가 뜬거다!
1. 스프링 부터가 제공하는 기본 기능
    - src → resources → static → index.html : 페이지가 뜬다
2. thymeleaf 템플릿 엔진
    - hello.hellospring > controller > helloController
        - @Controller :  헤당 클래스가 controller 임을 명시
        - @GetMapping : 웹 서버에서 / 무언가로 들어왔을때 아래의 method를 호출함
        - model :
        - resource > templates > hello.html : 헤당 html 에 thymeleaf를 선언해준다.
        - 앞서 model에서 선언한 key에 맞게 value가 html에 적용된다.
        
        <aside>
        💡 웹 브라우져는 :8080/hello 를 받고, 톰캣 내장 서버에 던진다. 그럼 스프링이 @GetMapping 을 통해 아래의 매소드를 실행시킨다. 이때 헤당 메소드에는 model이 넘어오는데 헤당 model은 key는 data고 값은 hello 다. 그 뒤 메소드는 hello를 리턴한다. 리턴값의 이름이 resource의 hello.html을 찾아서 랜더링 하라는 뜻이다. 이때 ViewResolver가 hello.html을 반환한다.
        
        </aside>
        
    
### 빌드하고 실행하기

1. ./gradlew build ( clean build는 완전히 재시작 )
2. cd build/libs
3. java -jar hello-spring-0.0.1-SNAPSHOT.jar
4. 실행 확인
---

## 스프링 웹 개발 기초

### 정적 컨텐츠

- 파일을 그대로 웹브라우저에 전달하는 방식
- resources > static > html 작성 : 그대로 웹서버에 헤당 파일이 그대로 등장한다.
- 원리 : 헤당 hello-static 에 헤당하는 controller 부재 → resources : static 에서 헤당 파일을 찾아 랜더링

### MVC와 템플릿 엔진

- 서버에서 좀 바꿔서 전달하는방식
- Model, View, Controller
    - View는 화면을 띄우는 것에만 집중
    - 내부로직은 반드시 Model과 Controller
- @RequestParam : 외부에서 name이라는 파라미터를 받는다. ( ?name =spring )
- 헤당 파라미터가 model의 value로 넘어가고, html로 넘어가서 화면에 띄워진다
- ViewResolver가 return과 똑같은 템플릿을 띄워주는데 파라미터 부분을 변환을 해서 넘겨준다.

### API 방식

- JSON으로 데이터만 내려줌 , Client와 소통 , 서버끼리 통신
- @ResponseBody : http 통신 Body에 return 내용을 직접 넣어주겠다
    - 템플릿엔진과 차이점은, 템플릿은 html태그를 포함한 템플릿 화면이 그대로 넘어가는데, API에서는 그냥 return 값 그자체만 그대로 넘어감
- class 내부에 또다른 class 만들때는 static class 로 선언해주기
    - 만든 hello에서 getName, setName 메소드를 만들어주고 리턴한다
    - 만약에 객체를 반환하면, 기본적으로 스프링에서는 json 을 만들어서 응답을 하겠다!(HttpMessageConverter)
        - 만일 Accept 헤드를 조작하면, 다른 타입으로도 줄수있다!

요약 : 정적 컨텐츠는 그대로 내려준다, MVC와 템플릿엔진은 htmld에 약간의 변환을 해준다, API는 JSON(기본) 으로 내린다

## 회원관리예제 - 백엔드 개발

### 비즈니스 요구사항 정리

데이터 : 회원 ID ,이름

기능 : 회원 등록, 조회

컨트롤러 : 웹 MVC의 C

서비스 : 핵심 비즈니스 로직 구현 - 기능 위주 구현

리포지토리 : DB에 접근 → 이번엔 interface로 구현할꺼임

도메인 : DB에 저장하고 관리되는

### 회원 도메인과 리포지토리

domain > Member class 

- id, name , 각각의 getter setter

repository > MemberRepository interface

- null 일수도 있는 변수의 경우에는 , Optional<타입>의 형태로 타입을 선언
- 원래는 이걸 DB로 구현해야하는데, 요 예제에서는 그냥 인터페이스로 간단하게 구현

repository > MemoryMemberRepository class

- MemberRepository interface 를 implements → option + Enter → interface에 헤당하는 모든 메소드 들을 추가할수있다.
- save : member를 받고, HashMap인 store를 선언하고, sequence를 하나씩 올려가며 store에 저장하고, 저장된  member를 리턴하고
- findById : store에서 id로 꺼내준다. 이때 null 가능성이 있기에 Optional로 감싸서 반환
- findByName : store에서 filter로 member의 name을 input과 비교해 찾고 반환 , findAny는 null이면 자동으로 optional
- findAll : ArrayList 객체 만들기, store.values반환

### 회원 리포지토리 테스트 케이스 작성

동작하는지 확인 ? → test case작성 : J unit

- test 폴더에 똑같이 MemoryMemberRepository + “Test” Class 생성
- new MemoryMemberRepository() 객체 만들기
- @Test : 테스트 메소드 별로 실행가능
    - save : repository에 멤버를 저장하고 (save), 아이디로 가져오고 (findById)
    - Assertions.assertEquals(A,B) A와 B가 같으면 녹색불
    - Assertions.assertThat(A).isEqualTo(result)로 쓸수도 있음
    - 매 테스트 할때마다 store.clear() → @AfterEach 할떄마다 clearstore 메소드 실행 : 서로 의존관계를 없애준다
    - 이때 test를 먼저 만들고(원하는 기능의 틀을 먼저 구현) → 이거에 딱 들어맞는 기능을 만드는 방식을 TDD (테스트 주도 개발)이라고 한다.
    

### 회원 서비스 개발

service > MemberService class

- 서비스를 만들려면 리포지토리 부터 있어야한다.
- 리포지토리는 좀더 개발적인 느낌, 서비스는 비즈니스 같은 이름
- join(회원가입) : MemberRepository에 save 해줌. 이때, 같은 이름 중복인지 아닌지 확인해야함
    - Command + Option + V : X를 type result = X 로 바꿔줌
    - result.ifPresent(값이 있으면 이게 동작한다.)
    - 근데 그냥 result 빼고, X.ifPresent로 바로 이어도 가능
    - 

### 회원 서비스 테스트

- Command+Shift + T : 한번에 테스트 작성가능
- 주석 :
    - given : 어떤 상황이 주어졌어
    - when : 이걸로 실행했을때
    - then : 결과가 이게 나와야댐
- 예외
    - try catch
    - assertThrows(이 에러, ()→ 요걸 실행할떄)
- 마찬가지로 반복적으로 clear해줘야한다.
- 테스트랑 원본이랑 같은 Repository로 테스트해줘야한다
    - MemberService의 경우 외부에서 Repository를 넣어주도록 바꿔야한다.
    - Service Test에서, @BeforeEach(동작하기 전에 실행) 을 통해, MemberService에 Repository를 넣어주고 실행한다